use std::process;
use wayland_client::{
    globals::{registry_queue_init, Global, GlobalListContents},
    protocol::wl_registry::{Event, WlRegistry},
    Connection, Dispatch, Proxy, QueueHandle,
};
use wayland_protocols_wlr::foreign_toplevel::v1::client::{
    zwlr_foreign_toplevel_handle_v1 as ftlh, zwlr_foreign_toplevel_manager_v1 as ftlm,
};

struct AppData {}

impl wayland_client::Dispatch<WlRegistry, ()> for AppData {
    fn event(
        state: &mut AppData,
        proxy: &WlRegistry,
        event: Event,
        // This mutex contains an up-to-date list of the currently known globals
        // including the one that was just added or destroyed
        data: &(),
        conn: &Connection,
        qhandle: &QueueHandle<AppData>,
    ) {
        if let Event::Global {
            name,
            interface,
            version,
        } = event
        {
            println!("[{}] {} (v{})", name, interface, version);
        }
    }
}

impl Dispatch<ftlh::ZwlrForeignToplevelHandleV1, ()> for AppData {
    fn event(
        state: &mut Self,
        proxy: &ftlh::ZwlrForeignToplevelHandleV1,
        event: <ftlh::ZwlrForeignToplevelHandleV1 as Proxy>::Event,
        data: &(),
        conn: &Connection,
        qhandle: &QueueHandle<Self>,
    ) {
        if let ftlh::Event::Title { title } = event {
            print!("{}", title);
        }
    }
}

impl Dispatch<ftlm::ZwlrForeignToplevelManagerV1, ()> for AppData {
    fn event(
        state: &mut Self,
        proxy: &ftlm::ZwlrForeignToplevelManagerV1,
        event: <ftlm::ZwlrForeignToplevelManagerV1 as Proxy>::Event,
        data: &(),
        conn: &Connection,
        qhandle: &QueueHandle<Self>,
    ) {
        if let ftlm::Event::Toplevel { toplevel } = event {
            print!(
                "Got ZwlrForeignToplevelManagerV1 event {}, data",
                toplevel.id()
            );
        }
    }
}

pub fn wayland_demo() {
    let mut state = AppData {};
    let conn = Connection::connect_to_env().unwrap_or_else(|e| {
        println!("Couldn't connect to Wayland server {:?}", e.to_string());
        process::exit(1)
    });

    let display = conn.display();

    let mut event_queue = conn.new_event_queue::<AppData>();
    let handle = event_queue.handle();

    let _registry = display.get_registry(&handle, ());

    println!("Advertised globals:");

    loop {
        event_queue
            .blocking_dispatch(&mut state)
            .unwrap_or_else(|e| {
                println!("Couldn't get global registry! {:?}", e.to_string());
                process::exit(1)
            });
    }
}
